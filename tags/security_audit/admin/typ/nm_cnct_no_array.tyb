CREATE OR REPLACE TYPE BODY nm_cnct_no_array IS
-----------------------------------------------------------------------------
--
--   SCCS Identifiers :-
--
--       sccsid           : @(#)nm_cnct_no_array.tyb	1.1 07/18/06
--       Module Name      : nm_cnct_no_array.tyb
--       Date into SCCS   : 06/07/18 15:52:07
--       Date fetched Out : 07/06/13 17:04:28
--       SCCS Version     : 1.1
--
--   Author : Rob Coupe
--
--   NM3 Connectivity object - node array type body
--
-------------------------------------------------------------------------------
--   Copyright (c) 2018 Bentley Systems Incorporated. All rights reserved.
-----------------------------------------------------------------------------

MEMBER FUNCTION add_element ( p_row_id IN INTEGER, p_no_id IN INTEGER, p_ne_id IN INTEGER, p_no_type IN VARCHAR2 ) RETURN nm_cnct_no_array IS
this_cnct_no nm_cnct_no_array := self;
l_extend_varray   BOOLEAN;
c_max_array_count CONSTANT BINARY_INTEGER := 1048576;
--
BEGIN
--
-- If there are NO entries in the VARRAY then extend it
--
   IF this_cnct_no.ncno_array.COUNT = 0
    THEN
      this_cnct_no.ncno_array.EXTEND;
   END IF;
--
-- If the last element in the array has a NULL pl_ne_id, then just update this entry when the time comes
--
   l_extend_varray := (ncno_array(this_cnct_no.ncno_array.LAST).no_id IS NOT NULL);
--
   -- If we are NOT just performing an update of the previous record
   --
   IF l_extend_varray
    THEN
      IF this_cnct_no.ncno_array.COUNT = c_max_array_count
       THEN
         RAISE_APPLICATION_ERROR(-20001,'NO Connection array cannot have more than '||c_max_array_count||' entries');
      END IF;
      this_cnct_no.ncno_array.EXTEND;
   END IF;
--
   this_cnct_no.ncno_array(this_cnct_no.ncno_array.LAST) := nm_cnct_no( p_row_id, p_no_id, p_ne_id, p_no_type );
--
   RETURN this_cnct_no;
--
EXCEPTION
   WHEN OTHERS
    THEN
      RETURN NULL;
--
END add_element;

MEMBER FUNCTION no_in_array ( p_no_id IN INTEGER ) RETURN INTEGER IS
this_cnct_no nm_cnct_no_array := self;
retval INTEGER := 0;
BEGIN
  FOR i IN 1.. this_cnct_no.ncno_array.LAST LOOP
    IF this_cnct_no.ncno_array(i).no_id = p_no_id THEN
	  retval := this_cnct_no.ncno_array(i).row_id;
      EXIT;
    END IF;
  END LOOP;
  RETURN retval;
END;

MEMBER FUNCTION get_disconnected_nodes  RETURN nm_cnct_no_array IS
this_cnct_no nm_cnct_no_array := self;
retval  nm_cnct_no_array;
no_tab  Nm3type.tab_number;
ne_tab  Nm3type.tab_number;
no_type Nm3type.tab_varchar1;
CURSOR get_no( c_no_array nm_cnct_no_array ) IS
  SELECT nm_cnct_no(n1.row_id, n1.no_id , n1.ne_id, n1.no_type)
  FROM TABLE ( c_no_array.ncno_array ) n1
  WHERE NOT EXISTS ( SELECT 1 FROM TABLE ( c_no_array.ncno_array ) n2
                     WHERE n1.no_id = n2.no_id
					 AND   n1.ne_id != n2.ne_id ) ;

BEGIN
  retval := nm_cnct_no_array( nm_cnct_no_array_type( nm_cnct_no( NULL, NULL, NULL, NULL)));
  OPEN get_no( this_cnct_no );
  FETCH get_no BULK COLLECT INTO retval.ncno_array;
  CLOSE get_no;

  RETURN retval;
END;

MEMBER FUNCTION get_element_in_array( p_no_id IN INTEGER ) RETURN nm_cnct_no IS
this_cnct_no  nm_cnct_no_array := self;
retval        nm_cnct_no := nm_cnct_no( NULL, NULL, NULL, NULL);
BEGIN
  FOR i IN 1..this_cnct_no.ncno_array.LAST LOOP
    IF this_cnct_no.ncno_array(i).no_id = p_no_id THEN
	  retval := this_cnct_no.ncno_array(i);
	  EXIT;
	END IF;
  END LOOP;
  RETURN retval;
END;

MEMBER FUNCTION distinct_nodes RETURN int_array IS
retval int_array := int_array( int_array_type( NULL));
this_cnct_no nm_cnct_no_array := self;
BEGIN
  SELECT DISTINCT n.no_id
  BULK COLLECT INTO retval.ia
  FROM TABLE ( this_cnct_no.ncno_array ) n;
  RETURN retval;
END;

MEMBER FUNCTION Xand( p_ia int_array ) RETURN nm_cnct_no_array IS
retval       nm_cnct_no_array;
this_cnct_no nm_cnct_no_array := self;
lc           INTEGER := 0;
ino          nm_cnct_no;
BEGIN
  retval := nm_cnct_no_array( nm_cnct_no_array_type( nm_cnct_no( NULL, NULL, NULL, NULL)));

/*
  FOR i IN 1..p_ia.ia.LAST LOOP
    IF i = 1 THEN
	  retval.ncno_array(i) := this_cnct_no.get_element_in_array( p_ia.ia(i));
	  retval.ncno_array.EXTEND( p_ia.ia.LAST -1);
	ELSE
	  retval.ncno_array(i) := this_cnct_no.get_element_in_array(p_ia.ia(i));
    END IF;
  END LOOP;
*/

  FOR i IN 1..p_ia.ia.LAST LOOP

    ino := this_cnct_no.get_element_in_array( p_ia.ia(i));

    IF ino.no_id IS NOT NULL THEN

      lc := lc + 1;

      IF i = 1 THEN
	    retval.ncno_array(lc) := ino;
  	  ELSE
	    retval.ncno_array.EXTEND;
	    retval.ncno_array(lc) := ino;
      END IF;

    END IF;
  END LOOP;

  RETURN retval;
END;




MEMBER FUNCTION furthest_2 RETURN int_array IS
this_cnct_no  nm_cnct_no_array := self;
TYPE tab_geom IS TABLE OF mdsys.sdo_geometry INDEX BY BINARY_INTEGER;
np_rows  Nm3type.tab_number;
np_array tab_geom;
ino int_array;
max_dist NUMBER := -1;
l_dist   NUMBER;
l_i      INTEGER;
l_j      INTEGER;
BEGIN
  ino := this_cnct_no.distinct_nodes;
  SELECT ROWNUM, npl_location
  BULK COLLECT INTO np_rows, np_array
  FROM NM_POINT_LOCATIONS, nm_nodes, TABLE ( ino.ia ) n
  WHERE no_np_id  = npl_id
  AND n.COLUMN_VALUE = no_node_id;

  IF np_rows.COUNT < 3 THEN

    RAISE_APPLICATION_ERROR(-20001, 'The set count is not greater than 2');

  ELSE

    FOR i IN 1..ino.ia.LAST - 1 LOOP
      FOR j IN (i+1)..ino.ia.LAST LOOP
        BEGIN
        	  l_dist := sdo_geom.sdo_distance( np_array(i), np_array(j), .05 );
        EXCEPTION
        WHEN OTHERS THEN
        Nm_Debug.debug_on;
        Nm_Debug.DEBUG('Here - the point is '||TO_CHAR(np_array(i).sdo_point.x)||','||TO_CHAR(np_array(i).sdo_point.y));
        Nm_Debug.DEBUG('Here - the point is '||TO_CHAR(np_array(j).sdo_point.x)||','||TO_CHAR(np_array(j).sdo_point.y));
        END;

  	    IF l_dist > max_dist THEN
  	      max_dist := l_dist;
  		  l_i      := i;
  		  l_j      := j;
  	    END IF;

  	  END LOOP;

    END LOOP;

  END IF;

  RETURN int_array( int_array_type(ino.ia(l_i), ino.ia(l_j)));
END;

MEMBER FUNCTION furthest_1 ( p_no_id IN INTEGER ) RETURN int_array IS
this_cnct_no  nm_cnct_no_array := self;
TYPE tab_geom IS TABLE OF mdsys.sdo_geometry INDEX BY BINARY_INTEGER;
np_rows  Nm3type.tab_number;
np_array tab_geom;
ino int_array;
max_dist NUMBER := -1;
l_dist   NUMBER;
l_i      INTEGER;
l_geom   mdsys.sdo_geometry;

BEGIN

--nm_debug.debug_on;

/*
  if p_no_id is null then
    nm_debug.debug('Null!!!');
  end if;
*/
  ino := this_cnct_no.distinct_nodes;

  SELECT ROWNUM, npl_location
  BULK COLLECT INTO np_rows, np_array
  FROM NM_POINT_LOCATIONS, nm_nodes, TABLE ( ino.ia ) n
  WHERE no_np_id  = npl_id
  AND n.COLUMN_VALUE = no_node_id;

--Nm_Debug.DEBUG('Bulk collected - '||TO_CHAR( np_rows.COUNT));

  FOR i IN 1..ino.ia.LAST LOOP
    IF ino.ia(i) = p_no_id THEN
	  l_geom := np_array(i);
	  EXIT;
	END IF;
  END LOOP;

--  Nm_Debug.DEBUG('target geometry found - now loop over the other shapes - '||TO_CHAR(ino.ia.LAST)||' of them ');

  FOR i IN 1..ino.ia.LAST LOOP
    IF ino.ia(i) != p_no_id THEN
      l_dist := sdo_geom.sdo_distance( l_geom, np_array(i), .05 );
--	  Nm_Debug.DEBUG('Distance '||TO_CHAR(i)||' = '||TO_CHAR(l_dist));
	  IF l_dist > max_dist THEN
	    max_dist := l_dist;
	    l_i      := i;
      END IF;
    ELSE
--	  Nm_Debug.DEBUG('This is the start node'||TO_CHAR(ino.ia(i)));
      NULL;
    END IF;
  END LOOP;

  IF max_dist = -1 THEN
    RAISE_APPLICATION_ERROR( -20001, 'There is no furthest node away from node '||TO_CHAR(p_no_id));
  END IF;

  RETURN int_array( int_array_type(p_no_id, ino.ia(l_i)));
END;

MEMBER FUNCTION get_elements_in_array( p_ia IN int_array ) RETURN nm_cnct_no_array IS
this_cnct_no  nm_cnct_no_array := self;
retval        nm_cnct_no_array := nm_cnct_no_array( nm_cnct_no_array_type(nm_cnct_no( NULL, NULL, NULL, NULL)));
BEGIN
  FOR j IN 1..p_ia.ia.LAST LOOP
    FOR i IN 1..this_cnct_no.ncno_array.LAST LOOP
      IF this_cnct_no.ncno_array(i).no_id = p_ia.ia(j) THEN
	    retval.ncno_array(retval.ncno_array.LAST) := this_cnct_no.ncno_array(i);
        retval.ncno_array.EXTEND;
	  END IF;
    END LOOP;
  END LOOP;
  retval.ncno_array.trim;
  RETURN retval;
END;



END;
/
