

create or replace package body inv as
--
--   SCCS Identifiers :-
--
--       sccsid           : @(#)inv.pkb_now_mai	1.1 03/01/01  -- @(#)inv.pck	1.4 12/21/99
--       Module Name      : inv.pkb_now_mai      -- inv.pck
--       Date into SCCS   : 01/03/01 16:23:06  -- 99/12/21 15:45:27
--       Date fetched Out : 07/06/13 14:10:39  -- 00/09/06 12:20:24
--       SCCS Version     : 1.1      -- 1.4
------------------------------------------------------------------
--   Copyright (c) 2013 Bentley Systems Incorporated. All rights reserved.
------------------------------------------------------------------
--
--   The Inventory library package.
--
--   Author : Rob Coupe
--
   g_body_sccsid     CONSTANT  VARCHAR2(2000) := '"@(#)inv.pkb_now_mai	1.1 03/01/01"';
--  g_body_sccsid is the SCCS ID for the package body
--
--
-----------------------------------------------------------------------------
--
FUNCTION get_version RETURN varchar2 IS
BEGIN
   RETURN g_sccsid;
END get_version;
--
-----------------------------------------------------------------------------
--
FUNCTION get_body_version RETURN varchar2 IS
BEGIN
   RETURN g_body_sccsid;
END get_body_version;
--
-----------------------------------------------------------------------------
--
/*
function get_iit_id ( p_pk_id in varchar2 ) return number is
cursor c1 is
  select iit_item_id
  from nm_inv_items
  where iit_primary_key = p_pk_id;
retval nm_inv_items.iit_item_id%type;
begin
  open c1;
  fetch c1 into retval;
  close c1;
  return retval;
end;
*/
function get_iit_pk ( p_item_id in number ) return varchar2 is
cursor c1 is
  select iit_primary_key
  from nm_inv_items
  where IIT_NE_ID   = p_item_id;
retval nm_inv_items.iit_primary_key%type;
begin
  open c1;
  fetch c1 into retval;
  close c1;
  if retval is null then
    retval :=  'Asset '||to_char(p_item_id );
  end if;
  return retval;
end;

function get_ity_descr ( p_ity in varchar2) return varchar2 is
cursor c1 is
  select nit_descr
  from nm_inv_types where nit_inv_type = p_ity;

retval nm_inv_types.nit_descr%type;

begin
  open c1;
  fetch c1 into retval;
  if c1%notfound then
    raise_application_error ( -20001, 'Invalid Inventory Type');
  end if;
  close c1;
  return retval;
  end;

function get_ity ( p_item_id  in number ) return varchar2 is
cursor c1 is
  select iit_inv_type
  from nm_inv_items where IIT_NE_ID  = p_item_id ;

retval nm_inv_types.nit_inv_type%type;

begin
  open c1;
  fetch c1 into retval;
  if c1%notfound then
    null;
  end if;
  close c1;
  return retval;
  end;
/*
function get_item_details ( p_item_id  in number ) return varchar2 is
cursor c1 is
  select Initcap( get_ity_descr( iit_inv_type ))||' - Asset '||iit_primary_key||
     'at '||to_char(iit_st_chain)
  from nm_inv_items where IIT_NE_ID  = p_item_id ;

retval varchar2(2000);

begin
  open c1;
  fetch c1 into retval;
  if c1%notfound then
    null;
  end if;
  close c1;
  return retval;
  end;
*/
/*
function get_xsp_offset_range( p_sys_flag in varchar2, p_scl_class in varchar2 ) return number is

cursor c1 is
  select sum( xsr_offset )
  from xsp_restraints
  where xsr_scl_class = p_scl_class
  and xsr_ity_inv_code = '$$'
  and xsr_ity_sys_flag = p_sys_flag;

retval number;

begin
  open c1;
  fetch c1 into retval;
  close c1;

  return retval;

end;
*/
/*
function get_xsp_descr( p_sys_flag in varchar2, p_scl_class in varchar2, p_x_sect_val in varchar2) return varchar2 is

cursor c1 is
   select xsr_descr
   from xsp_restraints
   where xsr_scl_class = p_scl_class
   and   xsr_ity_inv_code = '$$'
   and   xsr_ity_sys_flag = p_sys_flag
   and xsr_x_sect_value = p_x_sect_val;

retval xsp_restraints.xsr_descr%type;

begin
  open c1;
  fetch c1 into retval;
  close c1;

  return retval;

end;
*/
function get_pk_column_name ( p_ity_inv_code in nm_inv_types.nit_inv_type%type )
   return varchar2 is

  cursor c1 is
    select ita_view_col_name
    from nm_inv_type_attribs
    where ita_attrib_name = 'IIT_PRIMARY_KEY'
    and  ita_inv_type = p_ity_inv_code;

  retval nm_inv_type_attribs.ita_view_col_name%type;
  c1found boolean;

  begin
    open c1;
    fetch c1 into retval;
    c1found := c1%found;
    close c1;
    if c1found then
      return retval;
    else
      raise_application_error(-20001, 'Column mapping does not exist');
    end if;
  end;

function ity_exists( p_ity in nm_inv_types.nit_inv_type%type ) return boolean is
cursor c1 is
  select 'x' from nm_inv_types
  where nit_inv_type = p_ity;
dummy varchar2(1);
retval boolean;
begin
  open c1;
  fetch c1 into dummy;
  retval := c1%found;
  close c1;
  return retval;
end;


procedure pop_inv_colours is

resource_busy exception;
pragma exception_init( resource_busy, -54 );

begin

  lock table nm_inv_type_colours in exclusive mode nowait;

  delete from nm_inv_type_colours;

  insert into nm_inv_type_colours
  ( col_id, ity_inv_code )
  select rownum, nit_inv_type
  from nm_inv_types;

exception
  when resource_busy then
    raise_application_error( -20001, 'Colour Map is being used, try again later ');
end;
/*
function get_last_mp_rse( p_ity in varchar2, p_rse_he_id in number, p_chain in number ) return number is

  cursor c1( c_rse_he_id number, c_chain number, c_ity varchar2 ) is
    select iit_st_chain, IIT_NE_ID
    from nm_inv_items
    where c_rse_he_id = iit_rse_he_id
    and iit_ity_inv_code = c_ity
    and iit_st_chain <= c_chain
    order by iit_st_chain desc;

  l_rse_he_id number;
  l_chain     number;
  l_item_id   number;

begin
  open c1( p_rse_he_id, p_chain, p_ity);
  fetch c1 into l_chain, l_item_id;
  if c1%notfound then
    l_item_id := -1;
  end if;
  close c1;
  return l_item_id;
end;
*/
/*
function get_last_mp( p_ity in varchar2, p_route in number, p_rse_he_id in number, p_chain in number ) return number is

  cursor c1( c_rse_he_id number ) is
    select rse_he_id
    from  road_segs, road_seg_membs_all
    where rse_pus_node_id_end = offsets.get_start_node( c_rse_he_id )
    and rse_he_id = rsm_rse_he_id_of
    and rsm_rse_he_id_in = p_route;

  n_rse_he_id number;
  l_chain     number;
  retval      number;
  l_rse_he_id number := p_rse_he_id;
  l_offset    number := p_chain;
  l_item_id   number := -1;

  l_ctr number := 0;
begin
dbms_output.put_line( 'Start of loop');
  while l_item_id = -1 loop
    l_ctr := l_ctr + 1;
    if l_ctr > 20 then
      exit;
    end if;

--   First get the MP on the current section at a chainage less than that supplied

     l_item_id := get_last_mp_rse( p_ity, l_rse_he_id, l_offset );
     retval := l_item_id;
dbms_output.put_line('Found '||to_char(retval));
     if l_item_id = -1 then

--     If no MP found then go back over all the connected sections, searching for the last one

       open c1( l_rse_he_id );
       n_rse_he_id := l_rse_he_id;
       fetch c1 into l_rse_he_id;
       if c1%notfound then
dbms_output.put_line('Not found a new section');
         retval := -1;
-- := get_section_offset( p_route, n_rse_he_id);
         close c1;
         exit;
       else
         l_offset := 999999;
dbms_output.put_line('Found a new section'||to_char(l_rse_he_id));

         close c1;
       end if;
     end if;

   end loop;

   return retval;
end;
*/
/*
function get_mp_offset( p_iit in number, p_route in number,
                        p_rse_he_id in number, p_chain in number ) return number is

cursor c1 is
  select rsm_route_begin_mp, iit_st_chain
  from road_seg_membs_all, nm_inv_items
  where rsm_rse_he_id_in = p_route
  and   rsm_rse_he_id_of = iit_rse_he_id
  and   iit_item_id = p_iit;

cursor c2 is
  select rsm_route_begin_mp
  from road_seg_membs_all
  where rsm_rse_he_id_in = p_route
  and rsm_rse_he_id_of = p_rse_he_id;

l_iit_offset number;
l_iit_chain  number;
l_rse_offset number;

l_gty  group_types.gty_group_type%type := offsets.get_gty( p_route );
l_gty_unit units.un_unit_id%type;

retval number;

begin

  l_gty_unit := higunit.get_gty_units( l_gty );

  if p_iit > 0 then
    open c1;
    fetch c1 into l_iit_offset, l_iit_chain;
    close c1;

    open c2;
    fetch c2 into l_rse_offset;
    close c2;

    l_rse_offset := l_rse_offset - l_iit_offset;

    if l_gty_unit != 1 then
       l_rse_offset := higunit.convert_unit( l_gty_unit, 1, l_rse_offset);
    end if;

    retval := l_rse_offset - l_iit_chain + p_chain;

  else
    if l_gty_unit != 1 then
      retval := higunit.convert_unit( l_gty_unit, 1, offsets.get_section_offset( p_route, p_rse_he_id )) + p_chain;
    else
      retval := offsets.get_section_offset( p_route, p_rse_he_id ) + p_chain;
    end if;
  end if;

  return retval;
end;
*/
-- Returns the table name for a given inventory type
-- On error returns null
function get_nit_inv_type (tablename in nm_inv_types.nit_table_name%type)
  return nm_inv_types.nit_inv_type%type is
  nit_inv_type nm_inv_types.nit_inv_type%type;
begin
  select nit_inv_type into nit_inv_type
  from nm_inv_types
  where nit_table_name=tablename;

  return nit_inv_type;

  exception
    when others then
      return null;
end;

  -----------------------------------------------------------------------------
  -- Procedure to validate and return foreign key value

  PROCEDURE valid_fk_ial
	( a_ial_domain	IN	nm_inv_attri_lookup.ial_domain%type
	, a_ial_dtp_code	IN	nm_inv_attri_lookup.ial_dtp_code%type
	, a_ial_meaning	IN OUT	nm_inv_attri_lookup.ial_meaning%type
  ) AS

  CURSOR c_ial IS
    SELECT ial_meaning
    FROM nm_inv_attri_lookup nial,nm_inv_domains nid
    WHERE nid.id_domain = nial.ial_domain
    AND   nial.ial_domain  = a_ial_domain
    AND   nial.ial_dtp_code =    a_ial_dtp_code
    AND   SYSDATE BETWEEN NVL(ial_start_date,SYSDATE)
                  AND     NVL(ial_end_date,SYSDATE);

  b_notfound BOOLEAN DEFAULT FALSE;

  BEGIN
    dbms_output.put_line('valid_fk_ial( '||a_ial_meaning||')');

    OPEN c_ial;
    FETCH c_ial INTO a_ial_meaning;
    b_notfound := c_ial%NOTFOUND;
    CLOSE c_ial;

    IF (b_notfound) THEN
       raise_application_error( -20001
         ,hig.replace_strings_in_message(g_thing_does_not_exist,a_ial_domain));
    END IF;

    dbms_output.put_line('valid_fk_ial( OUT: '||a_ial_meaning||')');
  END valid_fk_ial;

  -----------------------------------------------------------------------------
  -- Procedure to validate and return foreign key value (Overloaded in
  -- the use of the date at which th evalidation is to apply. )
  -- The date is passed as a varchar2 of a specified mask since Pl/SQL 1
  -- differs in the way date parameters are held to PL/SQL 2.
  --
  PROCEDURE valid_fk_ial
	( a_ial_domain	IN	nm_inv_attri_lookup.ial_domain%type
	, a_ial_dtp_code	IN	nm_inv_attri_lookup.ial_dtp_code%type
	, a_ial_meaning	IN OUT	nm_inv_attri_lookup.ial_meaning%type
	, a_effective   IN      varchar2
	, a_date_mask   IN      varchar2 := 'DD-MON-YYYY'
  ) AS


  CURSOR c_ial IS
    SELECT ial_meaning
    FROM nm_inv_attri_lookup nial,nm_inv_domains nid
    WHERE nid.id_domain = nial.ial_domain
    AND   nial.ial_domain  = a_ial_domain
    AND   nial.ial_dtp_code =    a_ial_dtp_code
    AND    to_date( nvl(a_effective,to_char(sysdate, a_date_mask)), a_date_mask ) BETWEEN
             NVL(ial_start_date,  to_date( nvl(a_effective, to_char(sysdate, a_date_mask)), a_date_mask))
      AND    NVL(ial_end_date,    to_date( nvl(a_effective, to_char(sysdate, a_date_mask)), a_date_mask));

  b_notfound BOOLEAN DEFAULT FALSE;
  BEGIN
    dbms_output.put_line('valid_fk_ial( '||a_ial_meaning||')');
    OPEN c_ial;
    FETCH c_ial INTO a_ial_meaning;
    b_notfound := c_ial%NOTFOUND;
    CLOSE c_ial;
    IF (b_notfound) THEN
       raise_application_error( -20001
         ,hig.replace_strings_in_message(g_thing_does_not_exist,a_ial_domain));
    END IF;
    dbms_output.put_line('valid_fk_ial( OUT: '||a_ial_meaning||')');
  END valid_fk_ial;


/* MAIN */
BEGIN  /* inv - automatic variables */
  /* instantiate common error messages */
  g_thing_already_exists := hig.get_error_message( 'HWAYS' ,122);
  g_thing_does_not_exist := hig.get_error_message( 'HWAYS' ,121);
end;
/
