CREATE OR REPLACE TYPE BODY nm_placement_array AS
-------------------------------------------------------------------------
--   PVCS Identifiers :-
--
--       PVCS id          : $Header:   //new_vm_latest/archives/nm3/admin/typ/nm_placement_array.tyb-arc   2.2   02 Dec 2016 18:48:08   Mike.Huitson  $
--       Module Name      : $Workfile:   nm_placement_array.tyb  $
--       Date into PVCS   : $Date:   02 Dec 2016 18:48:08  $
--       Date fetched Out : $Modtime:   02 Dec 2016 18:46:24  $
--       Version          : $Revision:   2.2  $
-------------------------------------------------------------------------
--   Copyright (c) 2016 Bentley Systems Incorporated. All rights reserved.
-------------------------------------------------------------------------
--
--
------------------------------------------------------------------------------------------------
--adds a new element to the varray.
--pl_mrg_mem is only set if you do not want this function to be clever where 2 bits of the same
--member are being inserted.
--
MEMBER FUNCTION add_element(SELF       IN OUT NOCOPY nm_placement_array
                           ,pl_ne_id   IN INTEGER
                           ,pl_start   IN NUMBER
                           ,pl_end     IN NUMBER
                           ,pl_measure IN NUMBER DEFAULT 0
                           ,pl_mrg_mem IN BOOLEAN DEFAULT TRUE)
  RETURN nm_placement_array IS
  --
  prior_ne_id      NUMBER;
  prior_start      NUMBER;
  prior_end        NUMBER;
  prior_measure    NUMBER;
  l_start          NUMBER := pl_start;
  l_extend_varray  BOOLEAN;
  --
  c_max_array_count CONSTANT BINARY_INTEGER := 1048576;
  --
BEGIN
  --
  -- If there are no entries in the VARRAY then extend it.
  --
  IF npa_placement_array.COUNT = 0
   THEN
      npa_placement_array.extend;
  END IF;
  --
  -- Get the start, end and measure of the previous section
  --
  prior_measure := NVL(npa_placement_array(npa_placement_array.LAST).pl_measure,0);
  prior_ne_id   := NVL(npa_placement_array(npa_placement_array.LAST).pl_ne_id,0);
  prior_start   := NVL(npa_placement_array(npa_placement_array.LAST).pl_start,0);
  prior_end     := NVL(npa_placement_array(npa_placement_array.LAST).pl_end,0);
  --
  -- If the last element in the array has a NULL pl_ne_id, then just update this entry when the time comes
  --
  l_extend_varray := (npa_placement_array(npa_placement_array.LAST).pl_ne_id IS NOT NULL);
  --
  IF pl_ne_id = prior_ne_id
   AND pl_start = prior_end
   AND pl_mrg_mem
   THEN
      --
      -- If this is the same NE and they are connected then update the previous record
      --  to have the pl_end set to this record
      -- i.e.  add_element for   NE_ID   START   END
      --                          123       0     20
      --                          123      20    120
      --                          123     120    200
      --                          123     220    500
      --                          354       0    300
      --  is stored as            123       0    200
      --                          123     220    500
      --                          354       0    300
      --
      l_start := prior_start;
      l_extend_varray := FALSE;
      --
  END IF;
  --
  -- If we are NOT just performing an update of the previous record
  --
  IF l_extend_varray
   THEN
      --
      IF npa_placement_array.COUNT = c_max_array_count
       THEN
          raise_application_error(-20001,'Placement Array cannot have more than '||c_max_array_count||' entries');
      END IF;
      --
      npa_placement_array.extend;
      --
  END IF;
  --
  npa_placement_array(npa_placement_array.LAST) := nm_placement(pl_ne_id
                                                               ,l_start
                                                               ,pl_end
                                                               ,pl_measure);
  --
  RETURN SELF;
  --
EXCEPTION
  WHEN others
   THEN
      RETURN NULL;
END add_element;
--
------------------------------------------------------------------------------------------------
--
MEMBER FUNCTION add_element(SELF       IN OUT nm_placement_array
                           ,pl_pl      IN nm_placement
                           ,pl_mrg_mem IN BOOLEAN DEFAULT TRUE)
  RETURN nm_placement_array IS
BEGIN
  RETURN add_element(pl_ne_id   => pl_pl.pl_ne_id
                    ,pl_start   => pl_pl.pl_start
                    ,pl_end     => pl_pl.pl_end
                    ,pl_measure => pl_pl.pl_measure
                    ,pl_mrg_mem => pl_mrg_mem);
END add_element;
--
------------------------------------------------------------------------------------------------
--
-- returns the index of the element with the given pl_ne_id
MEMBER FUNCTION find_element(pl_ne_id IN INTEGER)
  RETURN INTEGER IS
  --
  l_retval INTEGER := 0;
  --
BEGIN
  --
  FOR i IN 1..npa_placement_array.LAST LOOP
    --
    IF npa_placement_array(i).pl_ne_id = pl_ne_id
     THEN
        -- Found a match so drop out of the loop
        l_retval := i;
        EXIT;
    END IF;
    --
  END LOOP;
  --
  RETURN l_retval;
  --
END find_element;
--
------------------------------------------------------------------------------------------------
--This function returns TRUE if the NM_PLACEMENT_ARRAY has no array entries, or there is only
--one entry and it is set to NULL
--
MEMBER FUNCTION is_empty
  RETURN BOOLEAN IS
  --
  l_retval BOOLEAN := FALSE;
  --
BEGIN
  --
  IF npa_placement_array.COUNT = 0
   THEN
      l_retval := TRUE;
  ELSIF npa_placement_array.COUNT = 1
   AND npa_placement_array(1).pl_ne_id IS NULL
   THEN
      l_retval := TRUE;
  END IF;
  --
  RETURN l_retval;
  --
END is_empty;
--
------------------------------------------------------------------------------------------------
--
MEMBER PROCEDURE dump_placement_array(SELF IN OUT NOCOPY nm_placement_array)
  IS
BEGIN
  IF is_empty
   THEN
      dbms_output.put_line ('Placement Array empty');
  ELSE
      FOR i IN 1..npa_placement_array.LAST LOOP
        dbms_output.put_line('Pos('||i||')'
                             ||'-'||npa_placement_array(i).pl_ne_id
                             ||','||npa_placement_array(i).pl_start
                             ||','||npa_placement_array(i).pl_end
                             ||','||npa_placement_array(i).pl_measure);
      END LOOP;
  END IF;
EXCEPTION
  WHEN others
   THEN
      RETURN;
END dump_placement_array;
--
------------------------------------------------------------------------------------------------
--
STATIC FUNCTION get_body_version
  RETURN VARCHAR2 IS
BEGIN
  RETURN '\$Revision:   2.2  $';
END get_body_version;
--
------------------------------------------------------------------------------------------------
--
MEMBER FUNCTION placement_count
  RETURN NUMBER IS
BEGIN
  --
  IF is_empty
   THEN
      RETURN 0;
  ELSE
      RETURN npa_placement_array.COUNT;
  END IF;
  --
END placement_count;
--
------------------------------------------------------------------------------------------------
--
MEMBER FUNCTION get_entry(pl_arr_pos IN INTEGER)
  RETURN nm_placement IS
BEGIN
  --
  IF NOT npa_placement_array.EXISTS(pl_arr_pos)
   THEN
      RETURN nm_placement(NULL,NULL,NULL,NULL);
  ELSE
      RETURN npa_placement_array(pl_arr_pos);
  END IF;
  --
END get_entry;
--
------------------------------------------------------------------------------------------------
--
END;
/
